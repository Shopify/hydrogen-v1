"use strict";(self.webpackChunkdocs_v_1=self.webpackChunkdocs_v_1||[]).push([[5214],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var r=n(7294);function s(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){s(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,s=function(e,t){if(null==e)return{};var n,r,s={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(s[n]=e[n]);return s}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(s[n]=e[n])}return s}var l=r.createContext({}),p=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=p(e.components);return r.createElement(l.Provider,{value:t},e.children)},u="mdxType",c={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,s=e.mdxType,a=e.originalType,l=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),u=p(n),m=s,h=u["".concat(l,".").concat(m)]||u[m]||c[m]||a;return n?r.createElement(h,o(o({ref:t},d),{},{components:n})):r.createElement(h,o({ref:t},d))}));function h(e,t){var n=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var a=n.length,o=new Array(a);o[0]=m;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i[u]="string"==typeof e?e:s,o[1]=i;for(var p=2;p<a;p++)o[p]=n[p];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},3095:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>a,metadata:()=>i,toc:()=>p});var r=n(7462),s=(n(7294),n(3905));const a={},o="Streaming server-side rendering (SSR)",i={unversionedId:"tutorials/streaming-ssr",id:"tutorials/streaming-ssr",title:"Streaming server-side rendering (SSR)",description:"Hydrogen 2.0 is out now. These archival Hydrogen 1.0 docs are provided only to assist developers during their upgrade process. Please migrate to Hydrogen 2.0 as soon as possible.",source:"@site/docs/tutorials/streaming-ssr.md",sourceDirName:"tutorials",slug:"/tutorials/streaming-ssr",permalink:"/tutorials/streaming-ssr",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"hydrogen",previous:{title:"Manage static assets",permalink:"/tutorials/static-assets/manage-static-assets"},next:{title:"Third-party dependencies",permalink:"/tutorials/third-party-dependencies"}},l={},p=[{value:"How streaming SSR works",id:"how-streaming-ssr-works",level:2},{value:"Example",id:"example",level:3},{value:"Benefits of streaming SSR",id:"benefits-of-streaming-ssr",level:2},{value:"Example",id:"example-1",level:3},{value:"Using Suspense",id:"using-suspense",level:2},{value:"How Suspense works",id:"how-suspense-works",level:3},{value:"Example: Layout fallback",id:"example-layout-fallback",level:3},{value:"Example: No Suspense component defined",id:"example-no-suspense-component-defined",level:3},{value:"Example: Suspense component defined",id:"example-suspense-component-defined",level:3},{value:"Next steps",id:"next-steps",level:2}],d={toc:p},u="wrapper";function c(e){let{components:t,...n}=e;return(0,s.kt)(u,(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"streaming-server-side-rendering-ssr"},"Streaming server-side rendering (SSR)"),(0,s.kt)("admonition",{type:"tip"},(0,s.kt)("p",{parentName:"admonition"},"Hydrogen 2.0 is out now. These archival Hydrogen 1.0 docs are provided only to assist developers during their upgrade process. Please ",(0,s.kt)("a",{parentName:"p",href:"https://shopify.dev/docs/custom-storefronts/hydrogen/migrate-hydrogen-remix"},"migrate to Hydrogen 2.0")," as soon as possible.")),(0,s.kt)("p",null,"You can improve your app's loading performance by rendering components on the server and streaming them to the client."),(0,s.kt)("p",null,"This guide describes how streaming server-side rendering (SSR) works in a Hydrogen app. It also explains how to use Suspense to manage asynchronous operations in your app."),(0,s.kt)("h2",{id:"how-streaming-ssr-works"},"How streaming SSR works"),(0,s.kt)("p",null,"Streaming SSR is a feature in React that allows you to load data over a network in multiple chunks. The chunks are loaded out of order in parallel to rendering, which makes your Hydrogen storefront fast and performant."),(0,s.kt)("blockquote",null,(0,s.kt)("p",{parentName:"blockquote"},"Note:\nStreaming SSR is critical for building performant storefronts, which typically depend on API calls to generate content on a page.")),(0,s.kt)("h3",{id:"example"},"Example"),(0,s.kt)("p",null,"The following clip shows an example of streaming content. The yellow boxes represent the content to display. As the streaming approaches 1.5 seconds, each yellow box gets replaced by a blue box at the specified time. The blue boxes represent that the data is ready:"),(0,s.kt)("p",null,(0,s.kt)("img",{parentName:"p",src:"https://shopify.dev/assets/custom-storefronts/hydrogen/streaming.gif",alt:"Example of streaming content"})),(0,s.kt)("p",null,"The following example shows the source code for a streamed document. The HTML that's being streamed in chunks is displayed out of order:"),(0,s.kt)("p",null,(0,s.kt)("img",{parentName:"p",src:"https://shopify.dev/assets/custom-storefronts/hydrogen/streaming-source.png",alt:"Source code for a streamed document"})),(0,s.kt)("h2",{id:"benefits-of-streaming-ssr"},"Benefits of streaming SSR"),(0,s.kt)("p",null,"Streaming SSR provides the following performance benefits:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Fast TTFB (Time to First Byte)"),": The browser streams the HTML page shell without blocking the server-side data fetch."),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("strong",{parentName:"li"},"Progressive hydration"),": As server-side data fetches are resolved, the data is streamed within the HTML response. The React runtime progressively hydrates the state of each component, all without extra client round trips or blocking on rendering the full component tree.")),(0,s.kt)("h3",{id:"example-1"},"Example"),(0,s.kt)("p",null,"You have a product page that contains a lot of buyer personalized content:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"A localized description and price for a given product"),(0,s.kt)("li",{parentName:"ul"},"A dynamic list of recommended products powered by purchase and navigation history"),(0,s.kt)("li",{parentName:"ul"},"A custom call to action or promotion banner")),(0,s.kt)("p",null,"The following table describes different strategies for implementing the product page, and the benefits of using a streaming SSR strategy:"),(0,s.kt)("table",null,(0,s.kt)("tr",null,(0,s.kt)("th",null,"Client-side strategy"),(0,s.kt)("th",null,"Server-side strategy"),(0,s.kt)("th",null," \u2705 Streaming SSR strategy")),(0,s.kt)("tr",null,(0,s.kt)("td",null,(0,s.kt)("p",null,"A client-side strategy might result in a fast render of an empty product page skeleton, with a series of post-render, browser-initiated fetches to retrieve and render the required content."),(0,s.kt)("br",null),(0,s.kt)("p",null,"However, client-initiated roundtrips usually result in a subpar user experience.")),(0,s.kt)("td",null,(0,s.kt)("p",null,"A server-side strategy might fetch the data on the server and return it in the response."),(0,s.kt)("br",null),(0,s.kt)("p",null,"However, server-side rendering offers a slow TTFB because the server is blocked on the data.")),(0,s.kt)("td",null,(0,s.kt)("p",null,"With a streaming SSR strategy in Hydrogen, you can stream, progressively hydrate, and render the product page to load content fast and efficiently."),(0,s.kt)("br",null),(0,s.kt)("p",null,"Streaming SSR contrasts with standard SSR, where TTFB is blocked until all data queries are resolved. Individual components can also show custom loading states as the page is streamed and constructed by the browser.")))),(0,s.kt)("h2",{id:"using-suspense"},"Using Suspense"),(0,s.kt)("p",null,"React 18 introduced ",(0,s.kt)("a",{parentName:"p",href:"https://nextjs.org/docs/advanced-features/react-18/streaming"},"Suspense for data fetching to complement streaming SSR"),". Suspense is a feature of React that governs the appearance and behavior of placeholder content inside components while asynchronous data-fetching is in progress."),(0,s.kt)("h3",{id:"how-suspense-works"},"How Suspense works"),(0,s.kt)("p",null,"Suspense establishes where you need to await an initiated data fetch. This means that Suspense doesn't define where you initiate fetching data. Instead, it specifies where you access the results of fetching data."),(0,s.kt)("p",null,"Suspense is implemented as a React component that wraps other components, so that each pair of Suspense tags corresponds to a Suspense boundary."),(0,s.kt)("p",null,"A Suspense boundary is any portion of React component code that's enclosed by a pair of Suspense component tags. The components in a Suspense boundary share common rendering behaviors while awaiting data controlled by Suspense. Multiple Suspense boundaries can co-exist within a single component, and Suspense boundaries can also be nested."),(0,s.kt)("h3",{id:"example-layout-fallback"},"Example: Layout fallback"),(0,s.kt)("p",null,"Suspense lets you render a fallback while a component is waiting for an asynchronous operation to finish. The following example shows how you can use ",(0,s.kt)("inlineCode",{parentName:"p"},"Suspense")," to add a layout fallback to improve cumulative layout shift (CLS):"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-jsx"},'// Product.server.jsx\n\nexport default function Product({country = {isoCode: \'US\'}}) {\n  const {handle} = useRouteParams();\n  return (\n    <Layout>\n      <Suspense\n        fallback={<ProductFallback handle={handle} isoCode={isoCode} />}\n      >\n        <Seo type="product" handle={handle} isoCode={isoCode} />\n        <ProductDetails handle={handle} isoCode={isoCode} />\n      </Suspense>\n    </Layout>\n  );\n}\nfunction ProductFallback() {\n  // This should have the same dimensions as the output of <ProductDetails />\n  return (\n    <div class="product-wrapper">\n      <div class="product-image-placeholder"></div>\n      <div class="product-info-placeholder"></div>\n    </div>\n  );\n}\n')),(0,s.kt)("h3",{id:"example-no-suspense-component-defined"},"Example: No Suspense component defined"),(0,s.kt)("p",null,"If you don't define a ",(0,s.kt)("inlineCode",{parentName:"p"},"Suspense")," component, then React waits for the streaming to finish before showing the final layout. The following clip shows a streamed document source that doesn't include a ",(0,s.kt)("inlineCode",{parentName:"p"},"Suspense")," component:"),(0,s.kt)("p",null,(0,s.kt)("img",{parentName:"p",src:"https://shopify.dev/assets/custom-storefronts/hydrogen/no-suspense.gif",alt:"A streamed document source that doesn't include a Suspense component"})),(0,s.kt)("h3",{id:"example-suspense-component-defined"},"Example: Suspense component defined"),(0,s.kt)("p",null,"When a ",(0,s.kt)("inlineCode",{parentName:"p"},"Suspense")," component is wrapped around a group of components that fetch data, it waits for the last component in the group to resolve before rendering. The order of the streamed content doesn't change in the streamed document source:"),(0,s.kt)("p",null,(0,s.kt)("img",{parentName:"p",src:"https://shopify.dev/assets/custom-storefronts/hydrogen/suspense-defined.gif",alt:"A streamed document source that includes a Suspense component"})),(0,s.kt)("h2",{id:"next-steps"},"Next steps"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},"Learn about ",(0,s.kt)("a",{parentName:"li",href:"/tutorials/react-server-components/"},"React Server Components"),", an opinionated data-fetching and rendering workflow for React apps."),(0,s.kt)("li",{parentName:"ul"},"Learn how to ",(0,s.kt)("a",{parentName:"li",href:"/tutorials/react-server-components/work-with-rsc/"},"work with React Server Components")," in your Hydrogen app.")))}c.isMDXComponent=!0}}]);